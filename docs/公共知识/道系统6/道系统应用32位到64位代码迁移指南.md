<div align='center' ><font size=6>道系统应用32位到64位代码迁移指南</font></div>
<br>
<div align="center">
    <img src="https://img.shields.io/badge/科银京成-blue" style="display: inline-block;">&nbsp;
    <img src="https://img.shields.io/badge/平台-道系统6 64位-orange" style="display: inline-block;">&nbsp;
    <img src="https://img.shields.io/badge/版本-1.0-red" style="display: inline-block;">&nbsp;
    <img src="https://img.shields.io/badge/日期-2022.01.08-ff69b4" style="display: inline-block;">
</div>

## 1.32位与64位数据类型定义

​    32位道系统使用的是***ILP32***数据模型，其中*I*代表*int*，*L*代表*long*，*P*代表*pointer*；64位道系统使用***LP64***数据模型，基于32位道系统开发的应用程序可能需要相应的检查和修改，才能在64位道系统中正确运行。

​    下表显示了两种数据模型的基本类型的大小(以bit为单位)，应特别注意*long*和指针类型：

| **数据类型** |            ILP32            |  LP64  |
| :----------: | :-------------------------: | :----: |
|     char     |              8              |   8    |
|    short     |             16              |   16   |
|     int      |             32              |   32   |
|   <mark>long</mark>   |           <mark>32</mark>            | <mark>64</mark> |
| <mark>pointer</mark>  |           <mark>32</mark>            | <mark>64</mark> |
|  long long   |             64              |   64   |
|    float     |             32              |   32   |
|    double    |             64              |   64   |
| long double  |             64              |  128   |
|    off_t     | 内核态：32 核心态：64 |   64   |
|   ssize_t    |             32              |   64   |
|  ptrdiff_t   |             32              |   64   |
|     enum     |             32              |   32   |

C99标准未定义*long double*类型，非特殊情况不建议使用。道系统使用的LLVM编译器对*long double*的定义如下表所示：

| 处理器架构 | sizeof(long double) |
| :--------: | :-----------------: |
|  ARM 32位  |       64 bit        |
|  ARM 64位  |       128 bit       |

​    ***ILP32***与***LP64***最主要的差别就是指针类型大小的变化，也是代码移植时首先应考虑的问题。*int*型变量不再能保存指针或任何地址。

​    注意：由于***LP64***数据模型中几种数据类型增大，任务运行在64位道系统中可能比运行在32位道系统中需要更大的栈空间。我们一般推荐将任务栈增大**35%-50%**，或根据应用程序酌情设置。推荐在开发时使用*checkStack()*确定任务栈的使用情况。

## 2.编译器辅助检查

​    编译器默认开启以下编译选项，用于编译时检查代码在32位和64位间的兼容性问题，建议用户消除所有的编译警告信息：

* **-Wall**
* **-Wconversion**
* **-Wno-sign-conversion**

   使用**\-Wall**选项，当代码出现类型转换不兼容的情况时会出现以下警告：

```bash
warning: cast to pointer from integer of different size 
warning: cast from pointer to integer of different size 
```

​    这通常是指针型变量和int型变量直接强制转换导致的。例如：

```c
tid = (int)taskIdCurrent;        /* 此处'tid'是int型 */ 
((ISR_ID)arg)->isrTag = ...;     /* 此处'arg'是int型 */ 
```

## 3.C代码移植注意项

### 3.1 *int*和*long*变量

​    在32位道系统中*int*和*long*类型都是32位，而64位道系统中*long*类型是64位。

​    64位道系统中不能将*int*型变量作为泛型，应检查应用程序中定义为*int*和*long*的所有变量，同时建议多使用_sizeof()_检查操作数的实际大小，以确保代码逻辑的正确。

### 3.2 地址与指针变量

​    32位硬件平台上*int*型和指针型变量的大小是相同的，但在64位系统中不相同。因此处理“**地址**”时不能使用*int*型变量，否则会出现数据截断（*Data truncation*）的问题。编译器并不会检测到类似问题，因此开发人员应检查地址类变量的声明和赋值，特别是函数的形参和返回值以及指针型数组的操作。

### 3.3 数据类型提升

​    应注意检查逻辑表达式、赋值和算术运算时的数据类型提升，详细信息建议参考C99标准。

### 3.4 强制类型转换

​    使用强制类型转换可以消除编译器警告信息，但这也会导致编译器无法对真正存在问题的代码做出警告。因此，最好的解决方式是更改变量类型，而不是使用强制转换。

### 3.5 格式串（*Format String*）转换

​    用户应注意修改*printf()*及相关函数格式串中的**转换说明**（*Conversion Specification*）。64位系统中，*long*型和指针型不能使用*%d*打印，*long*型应使用_%ld_，指针型使用_%p_。

### 3.6 常量

​    用户需检查所有常量的使用：

* 整型常量：无后缀的整型常量都被解释为能表示该常量的最小类型（最小为*int*型）。例如，整型常量0xFFFFFFFF是*int*型；0x100000000在32位系统中是*long long*型，在64位系统中是*long*型。
* 0xFFFFFFFF：在64位系统中0xFFFFFFFF不等于-1，这可能会导致一些应用代码逻辑出现问题。即便在常量后加上*L*后缀也不行，这只会告诉编译器它是一个*long*型，编译器不会将0xFFFFFFFF扩展为0xFFFFFFFFFFFFFFFF。
* ERROR：检查函数的ERROR状态应使用*ERROR*或*OK*常量，且必须使用相等或不等操作符(不能将*ERROR*和0xFFFFFFFF比较)。大于和小于操作符不能与*ERROR*常量一起使用。
* 位掩码：由于*long*型大小发生了变化，因此应仔细检查代码中与*long*型相关的逻辑掩码操作。

### 3.7 结构体和联合体

​    结构体在32位和64位系统中的大小和对齐可能不同，建议可以将结构体中的*long*型和指针型成员移至结构体起始位置，以尽可能的使结构体自然对其。

​    用户应仔细检查联合体成员类型，例如在32位环境中联合体成员为*int*型和*long*型代码逻辑正常，但在64位环境中则可能存在错误，需要注意不要将64位数据存储在联合体的32位成员中，这会导致数据截断，且编译器可能不会产生相关的警告信息。

### 3.8 使用函数声明

​    默认情况下，编译器假定函数的返回值为*int*型，如果函数的返回值为*long*型或指针型，且用户没有显示声明函数原型，那么编译器生成的代码会将返回值截断为32位，造成逻辑错误。强烈建议用户对函数进行显式的声明或包含正确的头文件。

### 3.9 使用可移植数据类型

当函数的形参和返回值是内存、文件或缓冲的偏移和大小时，可按以下规则修改变量的类型：

* 表示文件的大小、偏移量、区域大小时，用*off_t*替换*int*和*unsigned int*
* 表示内存或缓冲大小，用*size_t*替换*unsigned int*
* 如果原返回值表示内存的大小，且可以是负数（通常为-1），可使用*ssize_t*；如果返回值只能为正，则使用*size_t*
