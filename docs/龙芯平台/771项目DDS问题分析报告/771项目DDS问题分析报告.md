<div align='center'><font size=8>771 DDS问题分析报告</font></div>
## 1.时间

2023年6月1日

## 2.项目

771所龙芯3A架构“道系统V6.0”采购项目

## 3.应用场景
在龙芯3a3000硬件上，运行709所DDS+道系统+系统院应用程序。

## 4.问题现象

709所DDS示例程序通过RTP方式加载并启动应用，当运行一段时间后，会出现网络瘫痪的现象，网络相关功能异常。而使用DKM方式加载启动并没有此问题。同时发现在采用RTP方式启动应用后，系统tNet0任务的CPU占用率会一直增加。

## 5.问题定位

### 5.1 排查思路
1. 是否由于应用程序进行绑核操作，导致CPU0的资源被大量消耗；
2. 查看异常情况时edr日志信息文件；
3. 进行分离试验，简化应用场景，排除多种因素的干扰；
4. 与vxWorks操作系统进行对比试验，缩小问题排查范围。

### 5.2 排查过程
1. 通过SPY输出信息发现，系统配置了4个CPU，只有CPU0的资源被耗尽，其余三个CPU都处于空闲状态，因此怀疑是RTP启动应用的过程中绑定了核。经过系统院确认，进行了应用绑核操作且绑定在0核，修改至CPU1上。修改后测试，QT界面无DDS数据显示，系统院软件人员分析是DDS任务没有向QT方发送数据，通过道系统下w命令查看到DDS的线程任务信号量死锁了。通过某项目DDS问题举一反三，龙芯平台下DDS需要进行绑核操作，否则偶发死锁情况，因此暂时排除绑核引发问题的可能。

2. 查看最新一次日期的错误日志发现内存被耗尽导致应用程序动态申请内存失败，怀疑应用运行过程中有内存泄漏的风险。通过分离试验，分别测试道系统空载运行、道系统+709所DDS示例程序、道系统+709所DDS示例程序+系统院应用，测试结果道系统空载运行无内存泄漏现象，道系统+709所DDS示例程序、道系统+709所DDS系统院应用均存在内存泄漏情况，因此初步推测内存泄漏是跟DDS应用相关，排查道系统+709所DDS示例程序。

3. DDS有两个测试例程，可以用来复现内存泄漏问题，分别对应DKM与RTP（核心态与用户态）。通过memShow监测内存泄漏情况，发现DKM不会存在内存泄漏，RTP有明显的内存泄漏。经过与vxWorks操作系统作对比实验，发现VxWorks操作系统下DDS示例程序DKM与RTP两种模式均无内存泄漏情况，初步推测该问题与DDS无关，排查道系统。

4. 确认交付给771所道系统开发环境版本，发现该版本网络协议栈在用户态存在问题，因此尝试替换道系统最新网络协议栈，测试发现RTP模式下DDS应用内存泄漏现象未复现,tNet0任务CPU占用率未持续上涨，因此确定该问题是由于道系统网络协议栈版本未同步更新导致。

## 6.问题原因

道系统网络协议栈内收发网络报文均会调用ipnet_pipe_get_reader接口，该接口目的是确定一个任务id对应一个reader对象，保证通过指定的管道收发消息。旧版本网络协议栈中采取双重校验方式校验一个任务id是否对应一个reader对象，其中一重校验方式存在问题。在内核态获取的为当前任务id，任务id对应的reader对象唯一；在用户态下获取的为进程id，进程拥有多个线程，进程id所对应的reader对象不唯一，因此用户态下双重校验返回失败。以下为校验实现代码：

> 旧版本：

``` C
/*
 *===========================================================================
 *                          ipnet_pipe_hash_cmp
 *===========================================================================
 * Description: Checks if "reader" matches "pid"
 * Parameters:  reader - a reader instance
 *              pid - a PID
 * Returns:     IP_TRUE if they match, IP_FALSE otherwise.
 *
 */
IP_STATIC unsigned
ipnet_pipe_hash_cmp(Ipnet_pipe_reader *reader, Ip_pid_t *pid)
{
	/*确保每个pid对应的reader对象是唯一的，即使pid相同，reader对象也应不同*/
    return (reader->pid == *pid && reader->hashKey == taskReservedFieldGet(*pid,1));
}
```

> 新版本

``` c
IP_STATIC unsigned
ipnet_pipe_hash_cmp(Ipnet_pipe_reader *reader, Ip_pid_t *pid)
{
    return (reader->pid == *pid);
}
```

由于校验判断返回失败，此时任务无对应的reader对象，会调用calloc为任务分配一个reader对象，再将reader->pid指向对应任务id，保证任务id和reader对象的对应关系。系统通过网络协议栈中的超时调度回调函数ipnet_pipe_gc_pid进行reader对象资源回收，当reader对象对应的任务不存在时，释放任务对应分配的reader对象，否则，任务对应reader对象资源不会释放。
RTP模式DDS任务持续收发网络数据，用户态下任务与reader对象校验不对应，就会一直为任务分配reader对象，DDS任务一直运行，分配的reader对象资源不会被释放，就会导致内存资源会慢慢被耗尽，从而引发问题。

## 7.结论
去除旧版本网络协议栈中一个任务id对应一个reader对象的双重校验，还原为一重校验。道系统网络协议栈只有一重校验，一重校验可以确保一个任务id对应一个reader对象是唯一的。

## 8.建议
道系统产品版本需严格管控，代码修改需测试充分，代码提交需严格审核。发现、解决严重产品问题后，应同步更新提供给客户，避免客户遇到相同问题从而影响项目进度。